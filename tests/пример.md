Посмотри, пожалуйста, код test_tags.py, я как мог заменил дублирование кода
на методы, которые вызываются в тех или иных тестах.

1. Там есть 2 метода, которые создают БД и таблицы в ней. И по окончанию тестов удаляют таблицы:

    создание БД и таблиц ----->
    
    ```python
    def setUp(self):
        self.app = app
        self.app.config.update({
            'SQLALCHEMY_DATABASE_URI': Config.TEST_DATABASE_URI
        })
        self.client = self.app.test_client()
        with self.app.app_context():
            db.create_all()
    ```

    удаление таблиц ----->      
    
    ```python
    def tearDown(self):
        with self.app.app_context():
            db.session.remove()
            db.drop_all()
    ```

    Я так понимаю, что это должно быть фикстурой формата:

    ```python
    @pytest.fixture
    def init_database():
        db.create_all()
        yield db
        db.drop_all()
    ```

    Никак не могу сообразить, как мне это сделать.
    
    **Ответ:**
    
    Тело функции *setUp* ставим перед *yield db*, оборачивая в контекст, *tearDown* ставим после *yield db*
    
    Так же хотелось бы, что бы фикстура не создавала файл.db, а дело происходило in memory,
    чтобы не костылить с подключением к основной БД, налету меняя config.
    В тот раз мы с тобой разбирали это - conn = sqlite3.connect(":memory:")
    Но там был SQL, а не ORM.
    
    **Ответ:**
    
    Попробуй конфиг *SQLALCHEMY_DATABASE_URI* прописать как *sqlite:///:memory:*.

2. Создание user.

    ```python
    def create_test_user1(self):
        user_data = {
            "username": 'admin',
            'password': 'admin'
        }

        user = UserModel(**user_data)
        user.save()
        res = self.client.get("/users")
        data = json.loads(res.data)
        self.assertEqual(res.status_code, 200)
        self.assertEqual(data[0]["username"], user_data["username"])
        return user_data
    ```

   Это, я так понимаю, тоже должно быть фикстурой и в аргумент, ей должна передаваться
   фикстура создания бд и таблиц - (init_database).
   А уже в ассерте теста они просто дергаются из файла conftest.py.

   Я правильно понял суть?

   Я честно, несколько часов потратил на поиски в интернете, но там есть, что угодно кроме того,
   что надо))). Открываешь unittest, полно примеров, все есть. И тут начинаешь думать, а я правильно ищу то,
   или это делается по другому)))

   Можешь, пожалуйста, написать, как это должно выглядеть и я уже потом, перепишу
   все вспомогательные методы на фикстуры.
   
   **Ответ:**
   
   Зависит от того, что ты хочешь сделать. Если тебе в нескольких тестах нужен предсозданный пользователь, то нужно написать авто-фикстуру, которая из названия теста, будет брать имя файла, в котором будут данные таблицы в виде json или yaml. Возможно такое сходу написать сложно. Так что рассмотрим просто решение с фикстурой.
   
   Где её размещать, зависит от использования, если она используется только в текущем файле, то нет смысла выносить в conftest.
   
    ```python
    @pytest.fixture
    def user_admin(init_db, client):
        user_data = {
            "username": 'admin',
            'password': 'admin'
        }

        user = UserModel(**user_data)
        user.save()
        yield user
    
    def test_get_user(user_admin, client):
        res = client.get("/users")
        data = json.loads(res.data)
        assert res.status_code == 200
        assert data[0]["username"] == user_admin.username
    ```
    
    Так же можно использовать параметризацию.
    
    
    ```python
    @pytest.mark.parametrize(
        "user_data",
        [
            {
                "username": 'admin',
                'password': 'admin'
            }
        ]
    )
    def test_get_user(user_data, client):
        user = UserModel(**user_data)
        user.save()
        res = client.get("/users")
        data = json.loads(res.data)
        assert res.status_code == 200
        assert data[0]["username"] == user_data["username"]
    ```


3. Вопрос про правильное использование try except, я написал вопрос в файле resources/user, со строки 32 по 63
